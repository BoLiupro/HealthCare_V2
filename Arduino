/*
* This part is the code of Arduino A
* the function are detect heart rate by MAX30102 and 
* send data to Arduino B
*/
#include <Wire.h>
#include "MAX30105.h"
#include "heartRate.h"
#include <SoftwareSerial.h>//importing serial port
MAX30105 particleSensor;
SoftwareSerial BT(8, 9); //setting serial port
const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred
float beatsPerMinute;
int beatAvg;
int timEs = 0;
void setup()
{
 Serial.begin(115200);
 Serial.println("Initializing...");
 BT.begin(9600);
 // Initialize sensor
 if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed
 {
 Serial.println("MAX30105 was not found. Please check wiring/power. ");
 while (1);
 }
 Serial.println("Place your index finger on the sensor with steady pressure.");
 particleSensor.setup(); //Configure sensor with default settings
 particleSensor.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running
 particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED
}
void loop()
{
 long irValue = particleSensor.getIR();
 if (checkForBeat(irValue) == true)
 {
 //We sensed a beat!
 long delta = millis() - lastBeat;
 lastBeat = millis();
 beatsPerMinute = 60 / (delta / 1000.0);
 if (beatsPerMinute < 255 && beatsPerMinute > 20)
 {
 rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array
 rateSpot %= RATE_SIZE; //Wrap variable
 //Take average of readings
 beatAvg = 0;
 for (byte x = 0 ; x < RATE_SIZE ; x++)
 beatAvg += rates[x];
 beatAvg /= RATE_SIZE;
 }
 } 
 if(timEs >= 50) {
 Serial.print("IR=");
 Serial.print(irValue);
 Serial.print(", BPM=");
 Serial.print(beatsPerMinute);
// BT.print("BPM=");
// BT.print(beatsPerMinute);
 Serial.print(", Avg BPM=");
 Serial.print(beatAvg);
// BT.print(", Avg BPM=");
 BT.print(beatAvg);
 BT.print('.');
 if (irValue < 50000){
 Serial.print(" No finger?");
 } 
 timEs = 0;
 Serial.println();
 } else {
 timEs = timEs + 1;
 }
 delay(1);
}

/*
* This part is the code of Arduino B
* the function are receive data from Arduino A
* check if heart attack happened
* send different messages in different situations
*/
#include<SoftwareSerial.h>
SoftwareSerial BT(8, 9); // RX,TX
SoftwareSerial softSerial1(4,5);
char val;
String vals;
int BPM;
boolean IsNewLine = false;
const int highRate=150; 
const int lowRate=30; 
 //we set BPM=150 the high rate, if BPM>150, we should
 //give out heart attack warning.
 //similarly, we set BPM=30 the low rate, if BPM<30, we 
 //should give out heart attack warning too.
int sendMeg(String phonenum,String text)//Function to send information
{
 char comdata=0;//Used to determine whether the last bit received is correct
 String phone="";//Telephone number storage
 phone="AT+CMGS=\""+phonenum+'\"'; //Concatenate AT instructions for entering numbers
 while (softSerial1.available() > 0){ //Clear the text in the soft interface
 comdata = softSerial1.read(); 
 delay(2);
 } 
 softSerial1.println("AT");//Send "AT" to GSM, see the response, soft interface should return "OK"
 delay(1000);
 while (softSerial1.available() > 2){ //If the number of characters returned by the soft interface is greater than 2
 comdata = softSerial1.read(); 
 Serial.print(comdata);//error warning
 delay(2);
 }
 if(comdata!='K')//Check that the "OK" was not received.
 {
 Serial.println("error1");//Error, Arduino is not connected to GMS, or GMS is broken
 return 0;
 }
 comdata=0; 
 softSerial1.println("AT+CMGF=1");//Set GSM text mode (for Sending English SMS messages)
 delay(500);
 while (softSerial1.available() > 2){ //If the number of characters returned by the soft interface is greater than 2
 comdata = softSerial1.read(); //Clear the text in the soft interface
 delay(2);
 }
 
 if(comdata!='K')//No "OK" received, GSM failed to set to GSM text mode
 {
 Serial.println("error2");
 return 0;
 } 
 comdata=0;
 softSerial1.println(phone);//Destination number to send
 delay(1000);
 while (softSerial1.available() > 1){ //If the number of characters returned by the soft interface is greater than 1
 comdata = softSerial1.read(); //Clear the text in the soft interface
 delay(2);
 }
 
 if(comdata!='>')//There is no received '>
 {
 Serial.println("error3"); //Failed to send SMS messages
 return 0;
 }
 comdata=0;
 softSerial1.print(text);//Send what is written
 delay(500);
 softSerial1.write(0x1A); //Enter a text message and send a SMS message
 Serial.println("successfully send message!"); //success
 
}
void setup() {
 Serial.begin(9600);
 BT.begin(9600);
}
void loop() {
 if(BT.available()){
 val=BT.read();
 vals=vals+val;
 if(val=='.'){
 BPM=atoi(vals.c_str());
 Serial.println(BPM);
 if(BPM>highRate){
 Serial.println("warning!!the heart rate is too high!");
 sendMeg("13973112505","warning!!the heart rate is too high!");// send SMS message
 // sendsim2("13973112505","ddd",softSerial1);
 delay(500*1000); 
 }
 else if(BPM<lowRate){ 
 Serial.println("warning!!the heart rate is too low!");
 sendMeg("13973112505","warning!!the heart rate is too low!");//send SMS message
 // sendsim2("13973112505","ddd",softSerial1);
 delay(500*1000);}
 vals="";
 }
 }
 delay(1);
}
