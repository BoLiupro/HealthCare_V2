// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id 'com.android.application' version '7.2.0' apply false
    id 'com.android.library' version '7.2.0' apply false
    id 'org.jetbrains.kotlin.android' version '1.6.21' apply false
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
Footer
© 2022 GitHub, Inc.
import pygame
# 导入pygame模块
print(pygame.ver)
# 检查pygame的版本，检查pygame有没有导入成功
 
EMPTY = 0
BLACK = 1
WHITE = 2
# 定义三个常量函数，用来表示白棋，黑棋，以及 空
 
black_color = [0, 0, 0]
# 定义黑色（黑棋用，画棋盘）
white_color = [255, 255, 255]
# 定义白色（白棋用）
 
# 定义棋盘这个类
class RenjuBoard(object):
 
    def __init__(self):
        # self._board = board = [[EMPTY] * 15 for _ in range(15)]
        # 将棋盘每一个交叉点都看作列表的一个元素位，一共有15*15共225个元素
        self._board = [[]] * 15                            
        self.reset()
    #重置棋盘
    def reset(self):
        for row in range(len(self._board)):
            self._board[row] = [EMPTY] * 15
    #定义棋盘上的下棋函数，row表示行，col表示列，is_black表示判断当前点位该下黑棋，还是白棋
    def move(self, row, col, is_black):
        if self._board[row][col] == EMPTY:
            self._board[row][col] = BLACK if is_black else WHITE
            return True
        return False
    # 给棋盘定义一个函数将自己在screen上面画出来，使用pygame.draw()函数。并且顺便将下了的棋子也画出来
    def draw(self, screen):
        for h in range(1, 16):
            pygame.draw.line(screen, black_color,
                             [40, h * 40], [600, h * 40], 1)
            pygame.draw.line(screen, black_color,
                             [h * 40,40], [h * 40, 600], 1)
        # 给棋盘加一个外框，使美观
        pygame.draw.rect(screen, black_color, [36, 36, 568, 568], 3)
 
        # 在棋盘上标出，天元以及另外4个特殊点位
        pygame.draw.circle(screen, black_color, [320, 320], 5, 0)
        pygame.draw.circle(screen, black_color, [160, 160], 3, 0)
        pygame.draw.circle(screen, black_color, [160, 480], 3, 0)
        pygame.draw.circle(screen, black_color, [480, 160], 3, 0)
        pygame.draw.circle(screen, black_color, [480, 480], 3, 0)
        #做2次for循环取得棋盘上所有交叉点的坐标
        for row in range(len(self._board)):
            for col in range(len(self._board[row])):
                # 将下在棋盘上的棋子画出来
                if self._board[row][col] != EMPTY:
                    ccolor = black_color \
                        if self._board[row][col] == BLACK else white_color
                    # 取得这个交叉点下的棋子的颜色，并将棋子画出来
                    pos = [40 * (col + 1), 40 * (row + 1)]
                    # 画出棋子
                    pygame.draw.circle(screen, ccolor, pos, 18, 0)
 
# 定义函数，传入当前棋盘上的棋子列表，输出结果，不管黑棋白棋胜，都是传回False，未出结果则为True
def is_win(board):
    for n in range(15):
        # 判断垂直方向胜利
        flag = 0
        # flag是一个标签，表示是否有连续以上五个相同颜色的棋子
        for b in board._board:
            if b[n] == 1:
                flag += 1
                if flag == 5:
                    print('黑棋胜')
                    return False
            else:
            # else表示此时没有连续相同的棋子，标签flag重置为0
                flag = 0
 
        flag = 0
        for b in board._board:
            if b[n] == 2:
                flag += 1
                if flag == 5:
                    print('白棋胜')
                    return False
            else:
                flag = 0
 
        # 判断水平方向胜利
        flag = 0
        for b in board._board[n]:
            if b == 1:
                flag += 1
                if flag == 5:
                    print('黑棋胜')
                    return False
            else:
                flag = 0
 
        flag = 0
        for b in board._board[n]:
            if b == 2:
                flag += 1
                if flag == 5:
                    print('白棋胜')
                    return False
            else:
                flag = 0
 
        # 判断正斜方向胜利
 
        for x in range(4, 25):
            flag = 0
            for i,b in enumerate(board._board):
                if 14 >= x - i >= 0 and b[x - i] == 1:
                    flag += 1
                    if flag == 5:
                        print('黑棋胜')
                        return False
                else:
                    flag = 0
 
        for x in range(4, 25):
            flag = 0
            for i,b in enumerate(board._board):
                if 14 >= x - i >= 0 and b[x - i] == 2:
                    flag += 1
                    if flag == 5:
                        print('白棋胜')
                        return False
                else:
                    flag = 0
 
        #判断反斜方向胜利
        for x in range(11, -11, -1):
            flag = 0
            for i,b in enumerate(board._board):
                if 0 <= x + i <= 14 and b[x + i] == 1:
                    flag += 1
                    if flag == 5:
                        print('黑棋胜')
                        return False
                else:
                    flag = 0
 
        for x in range(11, -11, -1):
            flag = 0
            for i,b in enumerate(board._board):
                if 0 <= x + i <= 14 and b[x + i] == 2:
                    flag += 1
                    if flag == 5:
                        print('白棋胜')
                        return False
                else:
                    flag = 0
 
    return True
 
 
def main():
    # 创建棋盘对象
    board = RenjuBoard()
    # 用于判断是下黑棋还是白棋
    is_black = True
    # pygame初始化函数，固定写法
    pygame.init()
    pygame.display.set_caption('五子棋-IT入门') # 改标题
    # pygame.display.set_mode()表示建立个窗口，左上角为坐标原点，往右为x正向，往下为y轴正向
    screen = pygame.display.set_mode((640,640))
    # 给窗口填充颜色，颜色用三原色数字列表表示
    screen.fill([125,95,24])
    board.draw(screen)  # 给棋盘类发命令，调用draw()函数将棋盘画出来
    pygame.display.flip()  # 刷新窗口显示
 
    running = True
    # while 主循环的标签，以便跳出循环
    while running:
        # 遍历建立窗口后发生的所有事件，固定写法
        for event in pygame.event.get():
            # 根据事件的类型，进行判断
            if event.type == pygame.QUIT:
                running = False
 
            elif event.type == pygame.KEYUP:
                pass
            # pygame.MOUSEBUTTONDOWN表示鼠标的键被按下
            elif event.type == pygame.MOUSEBUTTONDOWN and \
                    event.button == 1:# button表示鼠标左键
                x, y = event.pos  # 拿到鼠标当前在窗口上的位置坐标
                # 将鼠标的(x, y)窗口坐标，转化换为棋盘上的坐标
                row = round((y - 40) / 40)     
                col = round((x - 40) / 40)
                if board.move(row, col, is_black):
                    is_black = not is_black
                    screen.fill([125, 95, 24])
                    board.draw(screen)
                    pygame.display.flip()
                    # 调用判断胜负函数
                    if not is_win(board):
                        #break
                        running = False
 
 
 
    pygame.quit()
 
 
 
if __name__ == '__main__':
    main()
————————————————
版权声明：本文为CSDN博主「曾亲桂林」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/bigzql/article/details/112386871

// pages/mulitplayer/mulitplayer.js

var num = [0, 0, 0, 0, 0, 0];
var oldNum = [0,0,0,0,0,0];
var players = [];
var index = 0;
var totalNum = [0,0,0,0,0,0];
Page({
  onLoad: function (options) {
    console.log(options);
    this.setData({
      num: Number(options.num),
    })
    if (this.data.num != 0){
      wx.setStorageSync('num', this.data.num);
    }
    
    for (var i = 0; i < this.data.num; i++) {
      players.push({
        name: "user" + i,
        record: [0, 0, 0, 0, 0, 0]
      })
    }
    this.setData({
      player: players,
    })
  },

  onShow: function () {
    this.setData ({
      total: totalNum,
      index: index+1,
    })
  },


  data: {
    player: [],
    total:[0,0,0,0,0,0],

    one_img: '../../image/6-point.gif',
    two_img: '../../image/6-point.gif',
    three_img: '../../image/6-point.gif',
    four_img: '../../image/6-point.gif',
    five_img: '../../image/6-point.gif',
    six_img: '../../image/6-point.gif',

    timer: null,
    txt: '什么都没摇到',
    flag: true,

    num: 0,

    dice: [
      '../../image/1-point.gif',
      '../../image/2-point.gif',
      '../../image/3-point.gif',
      '../../image/4-point.gif',
      '../../image/5-point.gif',
      '../../image/6-point.gif',
    ],
    one: 0,
    two: 0,
    three: 0,
    four: 0,
    five: 0,
    six: 0,

    index:1,

    hiddenmodalput:true,
    inputValue: '',
    inputShowed: false,
  },

  begin: function (event) {
    let obj = this;
    var audio = wx.createInnerAudioContext()
    var url = "audio/dice_audio.mp3"
    audio.src = url // src 可以设置 http(s) 的路径，本地文件路径或者代码包文件路径
    audio.play()
    var point = [0, 0, 0, 0, 0, 0];
    let f = obj.data.flag;
    if (f == true) {
      obj.data.timer = setInterval(function () {

        let one = Math.floor(Math.random() * 6);
        let two = Math.floor(Math.random() * 6);
        let three = Math.floor(Math.random() * 6);
        let four = Math.floor(Math.random() * 6);
        let five = Math.floor(Math.random() * 6);
        let six = Math.floor(Math.random() * 6);

        obj.setData({
          one_img: obj.data.dice[one],
          two_img: obj.data.dice[two],
          three_img: obj.data.dice[three],
          four_img: obj.data.dice[four],
          five_img: obj.data.dice[five],
          six_img: obj.data.dice[six],

          one: one,
          two: two,
          three: three,
          four: four,
          five: five,
          six: six,

          flag: false,
          point: point,
          txt: obj.txt,
        })
      }, 100);
    }

    setTimeout(() => {
      clearInterval(obj.data.timer);
      var point = [0, 0, 0, 0, 0, 0];
      var result = "";

      point[obj.data.one]++;
      point[obj.data.two]++;
      point[obj.data.three]++;
      point[obj.data.four]++;
      point[obj.data.five]++;
      point[obj.data.six]++;

      if (point[3] == 4) {
        if (point[0] == 2) {
          result = "状元插金花";
          num[5] = num[5] + 1;
        } else {
          result = "状元";
          num[5] = num[5] + 1;
        }
      } else if (point[3] == 6) {
        result = "获得：六杯红";
        num[5] = num[5] + 1;
      } else if (point[0] == 6) {
        result = "获得：遍地锦";
        num[5] = num[5] + 1;
      } else if (point[1] == 6 && point[2] == 6 && point[4] == 6 && point[5] == 6) {
        result = "获得：六杯黑";
        num[5] = num[5] + 1;
      } else if (point[3] == 5) {
        result = "获得：五王";
        num[5] = num[5] + 1;
      } else if (point[0] == 5 && point[1] == 5 && point[2] == 5 && point[3] == 5 && point[4] == 5 && point[5] == 5) {
        result = "获得：五子登科";
        num[5] = num[5] + 1;
      } else if (point[0] == 1 && point[1] == 1 && point[2] == 1 && point[3] == 1 && point[4] == 1 && point[5] == 1) {
        result = "获得：对堂";
        num[4] = num[4] + 1;
      } else if (point[3] == 3) {
        result = "获得：三红";
        num[3] = num[3] + 1;
      } else if (point[0] == 4 && point[1] == 4 && point[2] == 4 && point[4] == 4 && point[5] == 4) {
        result = "获得：四进";
        num[2] = num[2] + 1;
      } else if (point[3] == 2) {
        result = "获得：二举";
        num[1] = num[1] + 1;
      } else if (point[3] == 1) {
        result = "获得：一秀";
        num[0] = num[0] + 1;
      } else {
        result = "什么都没摇到";
      }

      for (var i=0;i<6;i++){
        totalNum[i] += num[i];
      }

      obj.setData({
        txt: result,
        flag: true,
        total: totalNum,
      })

      oldNum = players[index].record;

      for (var i=0;i<6;i++) {
          num[i]+=oldNum[i];
      }

      players[index] = {
        name: "user" + index,
        record: num
      };
      num = [0, 0, 0, 0, 0, 0];
      

      if (index == this.data.num-1) {
        index = 0;
      } else {
        index++;
      }
      
      obj.setData({
        player: players,
        index: index+1,
      })


    }, 1000);

  },

  end: function () {
    wx.showModal({
      title: '提示',
      content: '是否结束博饼？',
      success: function(res) {
      if (res.confirm) {
        wx.setStorageSync('num', 0);
        num = [0, 0, 0, 0, 0, 0];
        oldNum = [0,0,0,0,0,0];
        players = [];
        index = 0;
        totalNum = [0,0,0,0,0,0];
        
        wx.navigateBack({
          url:'/pages/game/game'
        })
      } else if (res.cancel) {
      
      }
      }
    })
  },

  add: function () {
    this.setData({  
      hiddenmodalput: false,
      inputShowed: true,
     }) 
  },
   //取消按钮  
 cancel: function(){  
  this.setData({  
    hiddenmodalput: true,  
    inputValue: '',
  });  
},  
//确认按钮
confirm: function(options){  
  let addNum = this.data.num + Number(this.data.inputValue);
  wx.setStorageSync('num', addNum);
  for (var i = 0; i < this.data.inputValue; i++) {
    players.push({
      name: "user" + i,
      record: [0, 0, 0, 0, 0, 0]
    })
  }

  this.setData({
    num: addNum,
    hiddenmodalput: true,
    player: players,
    inputValue: "",
  })
  
console.log(this.data.num);


},

input: function (options) {
  this.setData({
    inputValue: options.detail.value,
  })
},
logBtn1:function(){
  wx.navigateTo({
    url:'/pages/award/award',
})
},
})
package com.utf8coding.healthcare.activities

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.ImageView
import android.widget.Toast
import com.bumptech.glide.Glide
import com.utf8coding.healthcare.R
import com.utf8coding.healthcare.networkRelated.NetworkUtils
import java.lang.Thread.sleep
import kotlin.concurrent.thread

@Suppress("TypeParameterFindViewById")
class LauncherActivity : BaseActivity() {
    private val launcherImageView: ImageView
        get(){
            return findViewById(R.id.launcherImageView) as ImageView
        }
    private val skipButton: Button
        get() {
            return findViewById(R.id.skipButton) as Button
        }
    private var isConnection = false
    private var isAutoStart = true
    private var countDown = 3

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_launcher)
        Glide.with(this).load("https://s1.ax1x.com/2022/04/07/qz31zt.jpg").into(launcherImageView)
        checkConnectivity()
        //跳过倒计时按钮逻辑：
        skipButton.setOnClickListener{
            isAutoStart = false
            startNextActivity()
            finish()
        }
        //倒计时：开线程，自动启动：
        thread {
            sleep(1000)
            runOnUiThread{
                skipButton.text = "跳过(2)"
            }
            countDown -= 1
            sleep(1000)
            runOnUiThread{
                skipButton.text = "跳过(1)"
            }
            countDown -= 1
            sleep(1000)
            if(isAutoStart){
                startNextActivity()
            }
        }
    }

    private fun checkConnectivity(){
        NetworkUtils.isNetworkConnected(
            onSuccess = {
                isConnection = true
            },
            onFailure = {
                isConnection = false
            }
        )
    }

    //启动不同Activity的方法：
    private fun startNextActivity(){
        if (isConnection) {
            val pref = this.getSharedPreferences("userData", Context.MODE_PRIVATE)
            val userName = pref.getString("userName", "")?: ""
            val passWord = pref.getString("passWord", "")?: ""
            val id = pref.getInt("id", -1)
            Log.i("launcher activity:", "auto logging in, userName: $userName, password: $passWord, id: $id")
            if (userName != "" && passWord != ""){
                NetworkUtils.login(userName, passWord, object: NetworkUtils.LoginNetListener{
                    override fun onSuccess() {
                        startMainActivity()
                    }
                    override fun onFailure() {
                        startLoginActivity()
                    }
                    override fun onWrongUser() {
                        startLoginActivity()
                    }
                    override fun onWrongPassword() {
                        startLoginActivity()
                    }
                })
            } else {
                startLoginActivity()
            }
        }  else {
            startLoginActivity()
        }

    }
    private fun startMainActivity(){
        val intent = Intent(this, MainActivity::class.java)
        startActivity(intent)
    }
    private fun startLoginActivity(){
        val intent = Intent(this, LoginActivity::class.java)
        startActivity(intent)
    }

    //overrides:
    override fun onPause() {
        super.onPause()
        isAutoStart = false
    }
    override fun onResume() {
        super.onResume()
        if(!isAutoStart){
            val intent = Intent(this, MainActivity::class.java)
            startActivity(intent)
        }
    }
    override fun onBackPressed() {
        ActivityCollector.finishAll()
    }
}
